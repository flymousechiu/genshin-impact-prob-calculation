#!/bin/python3.8

S = """
原神教我学数学/编程系列 - 第一季
制作者: 慕茗
崩崩: 52318190, 原神: 100042481
不打工, 不教书, 比较忙, 看心情/时间解疑.
不代表任何官方观点, 不为计算结果做出任何实际意义的保证
仅作为个人娱乐/参照使用
"""

import numpy as np

def 制作指数概率分布(单次成功概率, 保底次数):
    # 1 次出的概率是(单次失败概率^0)*单次成功概率,
    # 2 次出的概率是(单次失败概率^1)*单次成功概率,
    # ...
    # n 次出的概率是(单次失败概率^(n-1))*单次成功概率
    # 如果全部失败, 总概率将在保底变成1,
    # 也就是保底那次的概率是:
    # 1 - (第一次出的概率+第二次出的概率+...+保底前一次出的概率)

    单次失败概率 = 1. - 单次成功概率

    # 概率总共有保底次数+1项, 因为包含n=0(一次都没抽就出)的概率
    概率 = np.zeros(保底次数 + 1, dtype=np.double)

    # 0, 1, 2, ..., 保底次数-2
    for i in range(保底次数 - 1):
        概率[i + 1] = (单次失败概率 ** i) * 单次成功概率

    # 概率最后一次 = 1 - 保底次数的总和
    概率[保底次数] = 1 - 概率.sum()

    # 输出概率
    return 概率


def 期盼值(概率):
    # 回答"样本足够多的话, 每个金平均要抽多少次?"
    # 根据概率质量分布来计算期盼值
    # 公式是 \sum_{x \in \mathbb{R}} x p(x)
    # 也就是针对所有可能出现的结果x, 把所有(x的值和其出现的概率的乘积)之和

    # 由于len(概率)是保底次数+1,
    # arange的输出为0, 1, ..., 保底次数
    x = np.arange(len(概率), dtype=np.double)

    # 输出两个数列的积的和
    return (x * 概率).sum()

def 综合概率(概率):
    # 回答"样本足够多的话, 平均每抽出金概率是多少?"
    # 很简单, 就是1 / 上面那个
    return 1 / 期盼值(概率)

# 晕了, 在这回答的问题似乎不对
# def 方差值(概率):
#     # 回答“样本足够多的话”
#     # 根据概率质量分布来计算方差值
#     # 公式是\sum_{x \in \mathbb{R}} x^2 p(x)
#     # 也就是针对所有可能出现的结果x, 把所有(x的值的平方和其出现的概率的乘积)之和

#     # 在样本的数量增大时(通常取样本数量>30), 样本平均值的统计分布趋近于标准分布
#     # 这时候可以用概率分布的方差值, 通过样本去评估做出假设的合理性
#     x = np.arange(len(概率), dtype=np.double)

#     return ((x ** 2) * 概率).sum()

def 实验(声明单次概率, 保底次数, 样本总数, 样本成功次数, 保底模式=True, alpha=0.05):
    # 通过将样本作为实验来分析, 如果概率=声明概率的话, 出现至少和样本一样极端的概率
    # 如果保底模式关闭, 则用标准的指数分布来计算(用于"综合概率"相应计算)

    try:
        from statistics import NormalDist
    except (ModuleNotFoundError, ImportError):
        print("估算工具需要python3.8以上版本运行\n跳过实验子程序...")
        return

    assert 样本总数 > 30, "样本不够大, 不适合用此法进行计算！"

    样本平均 = 样本成功次数 / 样本总数
    if 保底模式:
        概率分布 = 制作指数概率分布(声明单次概率, 保底次数)
        期盼平均 = 综合概率(概率分布)
        # 由于原始分布过于奇怪, 采用此法估算
        # \frac{1}{n-1}\sum_{i=1}^N (x_i - \mu_x)^2
        样本方差值 = (1 / (样本总数 - 1)) * (样本成功次数 * ((1 - 样本平均) ** 2) + (样本总数 - 样本成功次数) * ((样本平均 - 0) ** 2))
        z = (样本平均 - 期盼平均) / np.sqrt(样本方差值)
    else:
        期盼平均 = 声明单次概率
        # p(1-p)/2/n
        精确方差值 = 声明单次概率 * (1 - 声明单次概率) / 2 / 样本总数
        z = (样本平均 - 期盼平均) / np.sqrt(精确方差值)

    标准分布 = NormalDist()
    至少与样本一样极端的概率 = 标准分布.cdf(-abs(z)) * 2

    if 至少与样本一样极端的概率 < alpha:
        print("p = {:.6f}, alpha = {:.6f}, 因指定的条件下出现比本实验更极端的情况概率低于alpha, 故以{:.2%}的可信度推翻指定的条件. 如需增加可信度, 可降低alpha. 如需增加精度, 可增加样本数.".format(
            至少与样本一样极端的概率, alpha, 1 - alpha))
    else:
        print("p = {:.6f}, alpha = {:.6f}, 因指定的条件下出现比本实验更极端的情况概率不低于alpha, 故没有证明任何东西. 如需增加可信度, 可降低alpha. 如需增加精度, 可增加样本数.".format(
            至少与样本一样极端的概率, alpha))

def 二分法计算(希望综合概率, 保底次数, 精确度=1e-5):
    低端 = 0.
    高端 = 1.

    for i in range(1000):
        猜测 = (低端 + 高端) / 2
        目前综合概率 = 综合概率(制作指数概率分布(猜测, 保底次数))
        if (abs(目前综合概率 - 希望综合概率) < 精确度):
            return 猜测
        elif 目前综合概率 < 希望综合概率:
            低端 = 猜测
        else:
            高端 = 猜测

    raise RuntimeError("不该这么多次还没结果啊, 哪里出问题了?")

def main():
    print(S)

    # 常驻, 角色
    p = 0.006
    g_p = 0.016
    保底次数 = 90
    print("原神公布的常驻池和角色池保底概率为{:.3%}, 综合概率为{:.3%}, {}次保底".format(p, g_p, 保底次数))
    print("但实际计算出来的综合概率为{:.3%}".format(综合概率(制作指数概率分布(p, 保底次数))))
    print("如需达成声称的综合概率, 每次的概率应成为{:.3%}".format(二分法计算(g_p, 保底次数)))
    N = 1540    # 常驻779, 角色741, 新手20
    s = 17 + 5  # 常驻6角色5武器, 角色池11角色, 新手0
    print("作者共抽{}次常驻/角色池, 共{}金. 如按声称的单抽概率进行样本实验:".format(N, s))
    实验(p, 保底次数, N, s, )
    print("如按声称的综合概率进行实验:")
    实验(g_p, 保底次数, N, s, 保底模式=False)

    # 武器
    p2 = 0.007
    g_p2 = 0.0185
    保底次数2 = 80
    print("原神公布的武器池池保底概率为{:.3%}, 综合概率为{:.3%}, {}次保底".format(p2, g_p2, 保底次数2))
    print("但实际计算出来的综合概率为{:.3%}".format(综合概率(制作指数概率分布(p2, 保底次数))))
    print("如需达成声称的综合概率, 每次的概率应成为{:.3%}".format(二分法计算(g_p2, 保底次数2)))


if __name__ == "__main__":
    main()